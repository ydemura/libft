ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memccpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memmove:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [OK] 
ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [OK] [FAILED] [OK] [CRASH] [OK] 
[fail]: your strrchr does not work with \0
Test code:
	char *src = "there is so \0ma\0ny \0 \\0 in t\0his stri\0ng !\0\0\0\0";
	char *d1 = strrchr(src, '\0');
	char *d2 = ft_strrchr(src, '\0');

	if (d1 == d2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strrchr: ||
  ft_strrchr: ||

[crash]: your strrchr crash because it read too many bytes or attempt to write on s !
Test code:
	char *src = electric_alloc(10);

	__builtin___strcpy_chk (src, "123456789", __builtin_object_size (src, 2 > 1 ? 1 : 0));
	ft_strrchr(src, 'a');
	src = electric_alloc_rev(10);
	__builtin___strcpy_chk (src, "123456789", __builtin_object_size (src, 2 > 1 ? 1 : 0));
	ft_strrchr(src, 'a');
	exit(TEST_SUCCESS);


ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [FAILED] [OK] [OK] [OK] 
[fail]: your strncmp does not cast in unsigned char the diff
Test code:
	char *s1 = "\200";
	char *s2 = "\0";
	int i1 = ((strncmp(s1, s2, 1) > 0) ? 1 : ((strncmp(s1, s2, 1) < 0) ? -1 : 0));
	int i2 = ((ft_strncmp(s1, s2, 1) > 0) ? 1 : ((ft_strncmp(s1, s2, 1) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncmp: |1|
  ft_strncmp: |-1|

[fail]: your strncmp does not work with non ascii chars
Test code:
	char *s1 = "\x12\xff\x65\x12\xbd\xde\xad";
	char *s2 = "\x12\x02";
	size_t size = 6;
	int i1 = ((strncmp(s1, s2, size) > 0) ? 1 : ((strncmp(s1, s2, size) < 0) ? -1 : 0));
	int i2 = ((ft_strncmp(s1, s2, size) > 0) ? 1 : ((ft_strncmp(s1, s2, size) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncmp: |1|
  ft_strncmp: |-1|

ft_strlcpy:    [FAILED] [OK] [FAILED] [FAILED] [FAILED] [OK] {not protected}
[fail]: your strlcpy does not works with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00];
	char buff2[0xF00];

	__builtin___memset_chk (buff1, 'A', sizeof(buff1) - 1, __builtin_object_size (buff1, 0));
	__builtin___memset_chk (buff2, 'A', sizeof(buff2) - 1, __builtin_object_size (buff2, 0));
	buff1[sizeof(buff1) - 1] = 0;
	buff2[sizeof(buff1) - 1] = 0;
	__builtin___strlcpy_chk (buff1, str, sizeof(buff1), __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strlcpy(buff2, str, sizeof(buff2));
	if (!memcmp(buff1, buff2, strlen(str) + 1))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcpy: ||
  ft_strlcpy: |the cake is a lie !|

[fail]: your strlcpy overflow the dest
Test code:
	char *str = "BBBB";
	char buff1[0xF00];
	char buff2[0xF00];

	__builtin___memset_chk (buff1, 'A', 20, __builtin_object_size (buff1, 0));
	__builtin___memset_chk (buff2, 'A', 20, __builtin_object_size (buff2, 0));
	__builtin___strlcpy_chk (buff1, str, sizeof(buff1), __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strlcpy(buff2, str, sizeof(buff2));
	if (!memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	for (register int __i = 0; __i < 20; ++__i)
	for (register int __i = 0; __i < 20; ++__i)
	exit(TEST_FAILED);

Diffs:
     strlcpy: |\x0  \x42 \x42 \x42 \x0  \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 |
  ft_strlcpy: |\x42 \x42 \x42 \x42 \x0  \x79 \x6f \x75 \x72 \x20 \x73 \x74 \x72 \x6c \x63 \x70 \x79 \x20 \x64 \x6f |

[fail]: your strlcpy does works whe size < strlen(src)
Test code:
	char *str = "hello !";
	char buff1[0xF00];
	char buff2[0xF00];
	size_t r1;
	size_t r2;

	__builtin___memset_chk (buff1, 'A', 20, __builtin_object_size (buff1, 0));
	__builtin___memset_chk (buff2, 'A', 20, __builtin_object_size (buff2, 0));
	r1 = __builtin___strlcpy_chk (buff1, str, 2, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	r2 = ft_strlcpy(buff2, str, 2);
	if (r1 == r2 && !memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	if (r1 != r2)
	{
	}
		for (register int __i = 0; __i < 20; ++__i)
		for (register int __i = 0; __i < 20; ++__i)
	}
	exit(TEST_FAILED);

Diffs:
     strlcpy: |\x68 \x0  \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 |
  ft_strlcpy: |\x68 \x65 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 |

[fail]: your strlcpy does not works with 0-length string
Test code:
	char *str = "";
	char buff1[0xF00];
	char buff2[0xF00];
	size_t r1;
	size_t r2;

	__builtin___memset_chk (buff1, 'A', 20, __builtin_object_size (buff1, 0));
	__builtin___memset_chk (buff2, 'A', 20, __builtin_object_size (buff2, 0));
	r1 = __builtin___strlcpy_chk (buff1, str, sizeof(buff1), __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	r2 = ft_strlcpy(buff2, str, sizeof(buff2));
	if (r1 == r2 && !memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	if (r1 != r2)
	{
	}
		for (register int __i = 0; __i < 20; ++__i)
		for (register int __i = 0; __i < 20; ++__i)
	}
	exit(TEST_FAILED);

Diffs:
     strlcpy: |\x0  \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 |
  ft_strlcpy: |\x0  \x0  \x0  \x0  \x0  \x0  \x0  \x0  \x61 \x62 \x63 \x64 \x65 \x66 \x67 \x68 \x69 \x6a \x6b \x6c |

ft_strlcat:    [FAILED] [FAILED] [FAILED] [OK] [OK] [OK] [OK] [OK] [CRASH] [FAILED] [OK] [OK] 
[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + 4;

	__builtin___strlcat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |there is no stars in the sky|
  ft_strlcat: |there is no stars in the skythe cake is a lie !|

[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + 4;
	size_t r1 = __builtin___strlcat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	size_t r2 = ft_strlcat(buff2, str, max);

	if (r1 != r2)
		exit(TEST_FAILED);
	char s1[4] = "";
	char s2[4] = "";
	r1 = __builtin___strlcat_chk (s1, "thx to ntoniolo for this test !", 4, __builtin_object_size (s1, 2 > 1 ? 1 : 0))
		;
	r2 = ft_strlcat(s2, "thx to ntoniolo for this test !", 4)
		;
	if (r1 != r2)
		exit(TEST_FAILED);
	exit(TEST_SUCCESS);

Diffs:
     strlcat: |42|
  ft_strlcat: |47|

[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + strlen("there is no stars in the sky");

	__builtin___strlcat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |there is no stars in the skythe cake is a lie |
  ft_strlcat: |there is no stars in the skythe cake is a lie !|

[crash]: your strlcat crash because it read too many bytes or attempt to write on buff !
Test code:
	const size_t size = 10;
	char *str = electric_alloc(size);
	char *buff = electric_alloc(size);

	__builtin___strcpy_chk (buff, "AB", __builtin_object_size (buff, 2 > 1 ? 1 : 0));
	__builtin___strcpy_chk (str, "CDEFGHI", __builtin_object_size (str, 2 > 1 ? 1 : 0));
	ft_strlcat(buff, str, 10);
	exit(TEST_SUCCESS);


[fail]: your strlcat return value is false
Test code:
	char *src = "aaa";
	char dst1[20];
	char dst2[20];
	int ret1;
	int ret2;

	__builtin___memset_chk (dst1, 'B', sizeof(dst1), __builtin_object_size (dst1, 0));
	__builtin___memset_chk (dst2, 'B', sizeof(dst2), __builtin_object_size (dst2, 0));
	__builtin___strlcat_chk (dst1, src, 20, __builtin_object_size (dst1, 2 > 1 ? 1 : 0));
	__builtin___strlcat_chk (dst1, src, 20, __builtin_object_size (dst1, 2 > 1 ? 1 : 0));
	ret1 = __builtin___strlcat_chk (dst1, src, 20, __builtin_object_size (dst1, 2 > 1 ? 1 : 0));
	ft_strlcat(dst2, src, 20);
	ft_strlcat(dst2, src, 20);
	ret2 = ft_strlcat(dst2, src, 20);
	if (ret1 == ret2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |23|
  ft_strlcat: |30|

ft_strnstr:    [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
[fail]: your strnstr does not work with basic input
Test code:
	char *s1 = "MZIRIBMZIRIBMZE123";
	char *s2 = "MZIRIBMZE";
	size_t max = strlen(s2);
	char *i1 = strnstr(s1, s2, max);
	char *i2 = ft_strnstr(s1, s2, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |(null)|
  ft_strnstr: |MZIRIBMZE123|

ft_atoi:       [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [KO] [KO] [OK] 
[fail]: your atoi is not working with blanks
Test code:
	char *n = "\t\v\f\r\n \f-06050";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
        atoi: |-6050|
     ft_atoi: |0|

[KO]: your atoi does not work with over long max value
Test code:
	char n[40] = "99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |-1|
     ft_atoi: |-469762049|

[KO]: your atoi does not work with over long min value
Test code:
	char n[40] = "-99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |0|
     ft_atoi: |469762049|

ft_calloc:     [OK] [OK] [OK] [OK] [OK] 
ft_strdup:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_substr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] {not protected}[FAILED] 
[fail]: your substr does not work when start >= ft_strlen(s)
Test code:
	char *str = "01234";
	size_t size = 10;
	char *ret = ft_substr(str, 10, size);

	if (!strncmp(ret, "", 1))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: ||
   ft_substr: | strjoin d|

ft_strjoin:    [OK] [OK] [OK] [OK] [OK] {not protected}
ft_strtrim:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] {not protected}
ft_split:      [FAILED] [OK] [FAILED] [OK] [OK] [OK] [FAILED] [OK] [FAILED] {not protected}
[fail]: your split does not work with basic input
Test code:
	char *string = "      split       this for   me  !       ";
	char **expected = ((char*[6]){"split", "this", "for", "me", "!", ((void *)0)});
	char **result = ft_split(string, ' ');

	split_cmp_array(expected, result);

Diffs:
       split: |split|
    ft_split: ||

[fail]: your split does not work with one word
Test code:
	char *s = "                  olol";
	char **result = ft_split(s, ' ');

	split_cmp_array(expected, result);

Diffs:
       split: |olol|
    ft_split: ||

[fail]: your split does not work with basic input
Test code:
	char *s = "split  ||this|for|me|||||!|";
	int i = 0;
	char **result = ft_split(s, '|');

	while (result[i])
	{
		if (strcmp(result[i], *expected))
		{
			exit(TEST_FAILED);
		}
		free(result[i]);
		i++;
		expected++;
	}
	free(result);
	exit(TEST_SUCCESS);

Diffs:
       split: |this|
    ft_split: ||

[fail]: your split does not work with basic input
Test code:
	char *s = "      split       this for   me  !       ";

	char **result = ft_split(s, ' ');
	while (*result)
	{
		if (strcmp(*result, *expected))
		{
			exit(TEST_FAILED);
		}
		result++;
		expected++;
	}
	exit(TEST_SUCCESS);

Diffs:
       split: |split|
    ft_split: |A|

ft_itoa:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [KO] [OK] 
[KO]: your itoa does not allocate the good size so the \0 test may be false
Test code:
	int size;
	char *i1;

	i1 = ft_itoa(0);
	size = get_last_malloc_size();
	if (size == 2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        itoa: |2|
     ft_itoa: |1|

ft_strmapi:    [OK] [OK] [OK] [OK] [CRASH] {not protected}
[crash]: you did not protect your malloc return
Test code:
	char *b = "override this !";

	char *newstr = ft_strmapi(b, f_strmapi);
	if (newstr == ((void *)0))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_putchar_fd: [OK] [OK] [KO] 
[KO]: your putchar_fd does not work with unicode
Test code:
	char buff[10];
	char buff2[10];
	int c = L'Ã¸';
	int len = 0;

	putwchart(c, &len, buff2);
	buff2[len] = 0;
	fd_to_buffer(2);
	ft_putchar_fd(c, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 10);
	if (!strcmp(buff, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
  putchar_fd: |ø|
ft_putchar_fd: |Ã¸|

ft_putstr_fd:  [OK] [OK] {not protected}
ft_putendl_fd: [OK] [OK] {not protected}
ft_putnbr_fd:  [OK] [FAILED] [FAILED] [FAILED] [FAILED] 
[fail]: your putnbr_fd does not work with int max
Test code:
	int i = 2147483647;
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
   putnbr_fd: |2147483647|
ft_putnbr_fd: |0|

[fail]: your putnbr_fd does not work with int min
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
   putnbr_fd: |-2147483648|
ft_putnbr_fd: |0|

[fail]: your putnbr_fd does not work with random numbers
Test code:
	int nbr;
	char buff[0xF0];

	srand(clock());
	nbr = rand();
	fd_to_buffer(2);
	ft_putnbr_fd(nbr, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	int nb = atoi(buff);
	if (nbr != nb)
	{
		exit(TEST_FAILED);
	}
	;
	srand(clock());
	nbr = rand();
	fd_to_buffer(2);
	ft_putnbr_fd(nbr, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (nbr != atoi(buff))
	{
		exit(TEST_FAILED);
	}
	;
	srand(clock());
	nbr = rand();
	fd_to_buffer(2);
	ft_putnbr_fd(nbr, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (nbr != atoi(buff))
	{
		exit(TEST_FAILED);
	}
	;
	srand(clock());
	nbr = rand();
	fd_to_buffer(2);
	ft_putnbr_fd(nbr, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (nbr != atoi(buff))
	{
		exit(TEST_FAILED);
	}
	;
	exit(TEST_SUCCESS);

Diffs:
   putnbr_fd: |4739574|
ft_putnbr_fd: |0|

[fail]: your putnbr_fd allocate memory, wtf ???
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
   putnbr_fd: |-2147483648|
ft_putnbr_fd: |0|

ft_lstnew:     [MISSING]
ft_lstadd_front: [MISSING]
ft_lstsize:    [MISSING]
ft_lstlast:    [MISSING]
ft_lstadd_back:[MISSING]
ft_lstdelone:  [MISSING]
ft_lstclear:   [MISSING]
ft_lstiter:    [MISSING]
ft_lstmap:     [MISSING]
